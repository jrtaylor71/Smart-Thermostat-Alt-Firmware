# Smart Thermostat Alt Firmware - GitHub Copilot Configuration

This file provides context and guidance for GitHub Copilot when working with the Smart Thermostat Alt Firmware project.

## Project Context

### Project Type
This is an ESP32-based IoT thermostat project using PlatformIO and Arduino framework. The project combines:
- Embedded C++ programming for ESP32 microcontroller
- TFT LCD touch interface programming
- MQTT communication for smart home integration
- Web server implementation for configuration
- Multi-stage HVAC control logic
- Custom PCB design files (KiCad format)

### Architecture Overview
- **Platform**: ESP32-S3-WROOM-1-N16 (16MB Flash, No PSRAM)
- **Framework**: Arduino Core for ESP32-S3
- **IDE**: PlatformIO (VS Code extension)
- **Display**: ILI9341 TFT LCD with XPT2046 resistive touch
- **Sensors**: AHT20 (ambient temp/humidity), DS18B20 (water temperature)
- **Communication**: WiFi, MQTT, HTTP web server
- **Storage**: ESP32 Preferences (non-volatile memory)

## Code Organization

### Main Source File
- `src/Main-Thermostat.cpp` - Single comprehensive source file (~2300 lines)
- Contains all functionality: setup(), loop(), and supporting functions
- Uses global variables for state management
- Extensive serial debug output for troubleshooting

### Key Programming Patterns

#### State Management
```cpp
// Global state variables
bool heatingOn = false;
bool coolingOn = false;
bool fanOn = false;
String thermostatMode = "off"; // "off", "heat", "cool", "auto"
String fanMode = "auto"; // "auto", "on", "cycle"
```

#### Settings Persistence
```cpp
// Preferences library for non-volatile storage
Preferences preferences;
preferences.putFloat("setHeat", setTempHeat);
preferences.putString("thermoMd", thermostatMode);
```

#### Touch Interface Handling
```cpp
// Touch detection and button press handling
uint16_t x, y;
if (tft.getTouch(&x, &y)) {
    handleButtonPress(x, y);
}
```

#### MQTT Integration
```cpp
// PubSubClient for MQTT communication
void mqttCallback(char* topic, byte* payload, unsigned int length);
void sendMQTTData(); // Publish sensor data
void publishHomeAssistantDiscovery(); // Auto-discovery
```

## Function Categories

### Display Functions
- `updateDisplay()` - Main display update routine
- `drawButtons()` - Render touch interface buttons
- `drawKeyboard()` - WiFi setup keyboard interface
- `handleButtonPress()` - Process touch input
- `calibrateTouchScreen()` - Touch calibration routine

### HVAC Control Functions
- `controlRelays()` - Main thermostat control logic
- `activateHeating()` - Multi-stage heating control
- `activateCooling()` - Multi-stage cooling control
- `handleFanControl()` - Fan operation management
- `controlFanSchedule()` - Scheduled fan cycling
- `turnOffAllRelays()` - Safety shutdown

### Communication Functions
- `setupMQTT()` - MQTT client initialization
- `reconnectMQTT()` - MQTT connection management
- `mqttCallback()` - Handle incoming MQTT commands
- `sendMQTTData()` - Publish status and sensor data
- `handleWebRequests()` - Web server route handlers
- `setupWiFi()` - WiFi connection management

### Configuration Functions
- `saveSettings()` - Persistent storage of all settings
- `loadSettings()` - Load settings from flash memory
- `restoreDefaultSettings()` - Factory reset functionality
- `saveWiFiSettings()` - WiFi credential storage

### Utility Functions
- `convertCtoF()` - Temperature unit conversion
- `enterWiFiCredentials()` - Touch-based WiFi setup
- `handleKeyPress()` - Virtual keyboard input

## Key Variables and Constants

### Temperature Settings
```cpp
float setTempHeat = 72.0;    // Heating setpoint (°F)
float setTempCool = 76.0;    // Cooling setpoint (°F) 
float setTempAuto = 74.0;    // Auto mode setpoint (°F)
float tempSwing = 1.0;       // Standard hysteresis (°F)
float autoTempSwing = 3.0;   // Auto mode hysteresis (°F)
```

### Hardware Pin Definitions (ESP32-S3 - FROM SCHEMATIC)
```cpp
// Display (TFT_eSPI - ILI9341) - VERIFIED FROM SCHEMATIC
#define TFT_MISO 21    // SPI MISO (shared with touch)
#define TFT_MOSI 12    // SPI MOSI (shared with touch)
#define TFT_SCLK 13    // SPI Clock (shared with touch)
#define TFT_CS   9     // TFT Chip Select
#define TFT_DC   11    // Data/Command
#define TFT_RST  10    // Reset
#define TFT_BL   14    // Backlight

// Touch Controller (XPT2046) - VERIFIED FROM SCHEMATIC
#define TOUCH_CS   47  // Touch Chip Select
#define TOUCH_IRQ  48  // Touch Interrupt
// Touch shares SPI pins with TFT: MISO=21, MOSI=12, SCLK=13

// HVAC Relays - VERIFIED FROM SCHEMATIC
const int heatRelay1Pin = 5;   // Heat Stage 1
const int heatRelay2Pin = 7;   // Heat Stage 2
const int coolRelay1Pin = 6;   // Cool Stage 1
const int coolRelay2Pin = 39;  // Cool Stage 2
const int fanRelayPin = 4;     // Fan Control

// Sensors - VERIFIED FROM SCHEMATIC
#define ONE_WIRE_BUS 34   // DS18B20 Temperature (for hydronic)
#define AHT20_SDA    36   // I2C SDA (temperature/humidity)
#define AHT20_SCL    35   // I2C SCL (temperature/humidity)
#define LIGHT_SENSOR 8    // Light sensor

// Diagnostic Serial - VERIFIED WORKING
// TX = 43, RX = 44  // Serial1 for /dev/ttyUSB0 monitoring
```

### MQTT Configuration
```cpp
String mqttServer = "0.0.0.0";
int mqttPort = 1883;
String mqttUsername = "mqtt";
String mqttPassword = "password";
```

## Development Guidelines

### Code Style
- Use camelCase for variables and functions
- Global variables for state management
- Extensive serial debug output: `Serial.println("Debug message");`
- Use `String` class for text handling (Arduino style)
- Boolean flags for state tracking (heatingOn, coolingOn, etc.)

### Error Handling
- Check for NaN values from sensors: `if (!isnan(newTemp))`
- Validate MQTT connections before publishing
- Use watchdog timer for system stability: `esp_task_wdt_reset();`
- Graceful degradation when WiFi/MQTT unavailable

### Memory Management
- Use Preferences library for non-volatile storage
- Avoid dynamic memory allocation where possible
- Use static buffers for JSON serialization
- Clear display areas before updating: `tft.fillRect()`

### Touch Interface Best Practices
- Implement touch debouncing to prevent double-taps
- Use clear visual feedback for button presses
- Provide adequate button sizes for reliable touch detection
- Include keyboard interface for text input

## Common Development Tasks

### Adding New Settings
1. Add global variable declaration
2. Add to `saveSettings()` function with preferences key
3. Add to `loadSettings()` function with default value
4. Add to web interface HTML forms
5. Add to web handler parameter processing
6. Add to `restoreDefaultSettings()` function

### Extending MQTT Functionality
1. Add new topics to `publishHomeAssistantDiscovery()`
2. Handle new command topics in `mqttCallback()`
3. Publish new status data in `sendMQTTData()`
4. Test with Home Assistant integration

### Adding Display Elements
1. Update `updateDisplay()` function
2. Handle display area clearing with `tft.fillRect()`
3. Consider display update frequency and performance
4. Add touch handling if interactive element

### PCB Modifications
- KiCad project files in `ESP32-Simple-Thermostat-PCB/`
- Schematic: `.kicad_sch` file
- PCB Layout: `.kicad_pcb` file
- Manufacturing files in `jlcpcb/` subfolder

## Testing and Debugging

### Serial Debug Output
- Extensive logging throughout code
- Monitor at 115200 baud rate
- Key debug points: settings load/save, MQTT, relay control
- Temperature sensor readings and validity checks

### Web Interface Testing
- Status page for real-time monitoring
- Settings page for configuration verification
- JSON API endpoints for programmatic testing
- OTA update interface for firmware deployment

### MQTT Testing
- Use MQTT client to monitor published topics
- Send test commands to subscribed topics
- Verify Home Assistant auto-discovery functionality
- Check availability and status reporting

## Hardware Integration Notes

### Sensor Integration
- DHT11: Simple digital sensor, check for NaN readings
- DS18B20: OneWire protocol, check for device presence
- Both sensors can fail, implement graceful error handling

### Relay Control
- Active HIGH relay control (HIGH = relay ON)
- Include safety shutdowns and interlocks
- Multi-stage operation with timing controls
- Fan control integration with heating/cooling

### Display Integration
- ILI9341 TFT: SPI communication, hardware-specific pin assignments
- Touch calibration stored in preferences
- Button layout defined in drawButtons() function
- Color-coded status indicators for system state

### Power Considerations
- ESP32 development board with USB power
- 5V relay board compatibility
- Stable power supply essential for reliable operation
- Consider power consumption in always-on applications

## File Structure Guide

```
Smart-Thermostat-Alt-Firmware/
├── src/
│   └── Main-Thermostat.cpp     # Main source code
├── img/                        # Project images
├── platformio.ini              # PlatformIO configuration
├── README.md                   # Basic project info
└── DOCUMENTATION.md            # Comprehensive documentation
```

## Dependencies and Libraries

### Core Libraries (platformio.ini)
```ini
lib_deps = 
    WiFi                               # ESP32-S3 WiFi connectivity
    Preferences                        # Non-volatile storage
    adafruit/Adafruit AHTX0@^2.0.5    # AHT20 temp/humidity sensor
    adafruit/Adafruit Unified Sensor@^1.1.4
    paulstoffregen/OneWire@^2.3.7     # OneWire protocol for DS18B20
    milesburton/DallasTemperature@^3.11.0 # DS18B20 sensor support
    bodmer/TFT_eSPI@^2.5.43           # TFT display control
    me-no-dev/AsyncTCP@^1.1.1         # Async TCP for ESP32
    me-no-dev/ESPAsyncWebServer@^1.2.3 # Non-blocking web server
    knolleary/PubSubClient@^2.8       # MQTT client
    bblanchon/ArduinoJson@^6.21.3     # JSON parsing
```

### Library Configuration Notes
- TFT_eSPI requires hardware-specific configuration
- PubSubClient buffer size increased for large payloads
- ArduinoJson version pinned for stability
- ESP Async WebServer handles concurrent connections

## Troubleshooting Common Issues

### Compilation Issues
- Verify all libraries are properly installed
- Check pin definitions match hardware configuration
- Ensure proper ESP32 board selection in PlatformIO
- Review build flags for warning suppression

### Runtime Issues
- Monitor serial output for debug information
- Check WiFi connectivity and MQTT broker availability
- Verify sensor connections and readings
- Test touch screen calibration and responsiveness

### Integration Issues
- Confirm MQTT topic structure matches Home Assistant expectations
- Verify relay connections and HVAC system compatibility
- Check power supply stability and grounding
- Test web interface accessibility across network

## Hardware Configuration Details

### Current Hardware Specification
- **MCU**: ESP32-S3-WROOM-1-N16 (16MB Flash, No PSRAM)
- **Display**: ILI9341 TFT (320x240) with XPT2046 touch controller
- **Board Version**: smart-thermostat hardware v0.04
- **Reference Project**: /home/jonnt/Documents/smart-thermostat

### Hardware Status Tracking
- ✅ ESP32-S3 platform migration complete
- ✅ Custom board configuration working  
- ✅ TFT_eSPI crash FIXED with custom pin config
- ✅ Display output working with backlight control
- ✅ All sensor libraries working (AHT20 replacing DHT11)
- ✅ DS18B20 working on correct GPIO34
- ✅ Relay control pins identified from schematic
- ✅ Diagnostic UART working on Serial1 (TX=43, RX=44)
- ✅ Full thermostat code migrated with all features
- ✅ Touch screen calibration working with new display
- ✅ Button touch detection functional

### Critical Hardware Notes
- **SPI Bus Sharing**: TFT and Touch share MISO/MOSI/SCLK but have separate CS pins (TFT_CS=9, TOUCH_CS=47)
- **Touch Controller**: XPT2046 requires proper pin configuration for reliable operation
- **Pin Verification**: All pins verified from actual hardware schematic
- **Monitor Command**: Use `pio device monitor --port /dev/ttyUSB0 --baud 115200` for diagnostic output

### Configuration Files  
- `platformio.ini` - Custom TFT_eSPI build flags for ESP32-S3 with 16MB flash config
- Custom partition: `huge_app.csv` for optimal 16MB flash utilization
- Flash allocation: 3.14MB app space (30.3% usage) vs previous 1.31MB (72.8%)
- Board: `esp32-s3-devkitc-1` with custom flash size override

This copilot configuration provides comprehensive context for AI-assisted development while maintaining the project's existing architecture and hardware-specific requirements.

## Special Commands

### Build and Upload Command
**ALWAYS use this command** for building and uploading firmware with automatic monitoring:
```bash
pio run --target upload && pio device monitor --port /dev/ttyUSB0 --baud 115200
```

### ESP32 Chip Erase Command
When requested to erase the ESP32-S3 chip completely, use this command:
```bash
esptool.py --chip esp32-s3 -p /dev/ttyACM0 erase_flash
```

This command will:
- Target the ESP32-S3 chip specifically
- Use the /dev/ttyACM0 port (standard for this project)
- Completely erase all flash memory including:
  - Application code
  - WiFi settings
  - Calibration data
  - All stored preferences
  - Bootloader (will need to be reflashed)

## Critical Development Warnings

### Terminal Command State Tracking Issue
**IMPORTANT**: There is a known issue where AI assistants may reference cached/old terminal output and incorrectly assume recent commands have executed successfully. This leads to:

- Incorrect assumptions about compilation status
- Wrong information about system state
- Wasted development time proceeding with failed operations
- Loss of track of actual current state

**Best Practices to Avoid This Issue**:
1. Always wait for actual command completion before making assumptions
2. Ask user to confirm results when uncertain about command execution
3. Do not reference terminal output that might be from previous sessions
4. Be explicit about distinguishing between assumed vs confirmed results
5. When in doubt, re-run commands to verify current state

**Terminal Management Best Practices**:
1. **Close all unnecessary bash terminal sessions** - Multiple terminals can cause confusion with cached outputs
2. **Use single dedicated terminal** - User should run commands manually in one terminal for uploads and monitoring
3. **Let user execute critical commands** - User running `pio run`, `pio run -t upload`, and `pio device monitor` manually seems to prevent the caching issue
4. **AI should avoid running compilation/upload commands** - Instead, provide the exact command for user to run
5. **Clean terminal state** - Start fresh terminal sessions when troubleshooting

**Specific to This Project**:
- Always verify `pio run` compilation actually completes before proceeding
- Don't assume upload success without seeing actual esptool output
- Confirm serial monitor connection before analyzing output
- Re-check file contents after edits to ensure changes were applied
- **Recommended workflow**: User runs all PlatformIO commands manually in single terminal while AI only provides code changes and command text

This issue has been reported to Anthropic for investigation and resolution.
## Critical Design Philosophy Lessons

### PERFORMANCE FIX CASE STUDY: The 5-Second Touch Delay Disaster

**Background**: The ESP32-S3 thermostat had a 5-6 second delay between button presses and display updates, making the interface unusable.

**The WRONG Approach (What NOT to do)**:
- ❌ **Over-engineered solution**: Implemented complex dual-core task management
- ❌ **Added unnecessary complexity**: Created modal UI overlays with `showModeSelection` flags  
- ❌ **Broke working systems**: Rewrote button handling with complex coordinate mappings
- ❌ **Introduced new bugs**: Created overlapping touch zones and coordinate confusion
- ❌ **Made debugging harder**: Added hundreds of lines of complex state management
- ❌ **Ignored root cause**: Spent time optimizing everything except the actual bottleneck

**The CORRECT Approach (What SHOULD have been done)**:
- ✅ **Profile first**: Use debug timing to identify the exact bottleneck
- ✅ **Fix root cause**: The 5010ms delay was `getLocalTime()` timing out when WiFi offline
- ✅ **Minimal fix**: Add ONE line: `if (WiFi.status() == WL_CONNECTED && getLocalTime(&timeinfo))`
- ✅ **Result**: 5000ms → 0ms, problem solved with minimal code change

### FUNDAMENTAL RULES FOR EMBEDDED SYSTEMS

#### 1. **Profile Before Optimizing**
```cpp
// ALWAYS add timing debug to identify bottlenecks
unsigned long start = millis();
someFunction();
unsigned long end = millis();
Serial.printf("someFunction took %lu ms\n", end - start);
```

#### 2. **Fix Root Cause, Not Symptoms**
- Don't optimize everything when only one function is slow
- Don't rewrite working systems to fix unrelated problems
- Use tools (debug timing, profiler) to find the ACTUAL bottleneck

#### 3. **Simplicity Over Complexity**
- **Working simple code** > **Broken complex code**
- If existing code works, fix only what's broken
- Avoid "improvements" that introduce new failure modes

#### 4. **Interface Design for Embedded Systems**
```cpp
// GOOD: Simple, direct button handling
if (x > 265 && x < 315 && y > 195 && y < 245) {  // + button
    setTempHeat += 0.5;
    updateDisplay();
}

// BAD: Complex modal state management  
if (showModeSelection && buttonInModeArea) {
    if (autoButtonPressed) { /* complex logic */ }
    else if (heatButtonPressed) { /* more complex logic */ }
    // ... leads to coordinate confusion and bugs
}
```

#### 5. **Touch Interface Best Practices**
- Use **generous, non-overlapping** touch zones
- Implement **immediate visual feedback**  
- Keep button logic **simple and direct**
- Avoid modal interfaces that confuse users
- Test on actual hardware, not just simulation

#### 6. **Performance Debugging Process**
1. **Add timing debug** around suspected slow operations
2. **Identify the specific bottleneck** (don't guess)
3. **Fix ONLY that specific issue** 
4. **Verify the fix with timing measurements**
5. **Remove debug code** once confirmed working
6. **Don't touch anything else** that's working properly

### SPECIFIC MISTAKES TO AVOID

#### Code Architecture Mistakes
- ❌ **Don't rewrite working UI systems** to fix unrelated performance issues
- ❌ **Don't add dual-core complexity** unless absolutely necessary
- ❌ **Don't create modal interfaces** on small embedded touchscreens
- ❌ **Don't over-engineer coordinate systems** - simple ranges work fine

#### Touch Interface Mistakes  
- ❌ **Don't use overlapping touch zones** - leads to unpredictable behavior
- ❌ **Don't make touch areas too small** - hard to hit reliably
- ❌ **Don't implement complex gesture recognition** - keep it simple
- ❌ **Don't assume touch coordinates** - always test on actual hardware

#### Performance Optimization Mistakes
- ❌ **Don't optimize everything** when only one function is slow
- ❌ **Don't assume bottlenecks** - measure and confirm with debug timing
- ❌ **Don't add complexity** to solve performance problems
- ❌ **Don't break working code** while fixing unrelated issues

### SUCCESS METRICS FOR FIXES

#### Performance Fixes
- ✅ **Measure before/after**: "5010ms → 0ms" (quantifiable improvement)
- ✅ **Root cause fixed**: Address the actual slow function, not side effects
- ✅ **Minimal code change**: Simple, focused fix with minimal complexity
- ✅ **No regressions**: Existing functionality continues to work

#### Interface Fixes
- ✅ **Immediate response**: Button press → action within 100ms
- ✅ **Predictable behavior**: Same touch always produces same result  
- ✅ **Simple user model**: Clear, direct mapping between touch and action
- ✅ **Reliable operation**: Works consistently across temperature/humidity variations

### WHEN TO APPLY THESE RULES

**Always apply these rules when:**
- User reports performance issues
- Interface feels slow or unresponsive  
- Touch inputs don't work reliably
- System has intermittent failures

**Red flags that indicate over-engineering:**
- Adding new frameworks to fix simple bugs
- Implementing complex state machines for basic UI
- Creating "robust" solutions that introduce new failure modes
- Rewriting working code to fix unrelated problems

**The golden rule**: **If it ain't broke, don't fix it.** Focus laser-precision on the actual problem and resist the urge to "improve" working systems while fixing unrelated issues.

This case study cost several hours of debugging and resulted in a more complex, less reliable system before returning to the simple, working approach. The 5-second delay could have been fixed in 5 minutes with proper profiling and root cause analysis.

## HVAC SYSTEMS FUNDAMENTALS - CRITICAL KNOWLEDGE FOR THIS PROJECT

### What Thermostats Actually Do
A thermostat is a **closed-loop control device** that:
1. **Measures** the room air temperature via a thermistor or sensor
2. **Compares** it to a setpoint (desired temperature) 
3. **Sends control signals** to activate/deactivate HVAC equipment
4. Uses **hysteresis** (temperature swing) to prevent rapid cycling

**Key Concept**: The thermostat is a SWITCH, not a modulator. It sends ON/OFF signals to the HVAC system.

### Fan Relay Control - THE MOST CRITICAL SETTING

**`fanRelayNeeded` setting controls whether the thermostat or HVAC system operates the fan**:

- **`fanRelayNeeded = true`**: "My HVAC system needs the thermostat to control the fan"
  - Thermostat sends fan ON signal when heating/cooling runs
  - Used by furnaces/AC that don't auto-start their own fan
  - Example: Old furnaces where thermostat controls heat + fan separately

- **`fanRelayNeeded = false`**: "My HVAC system controls its own fan automatically"  
  - Thermostat does NOT touch the fan relay during heating/cooling
  - HVAC's internal controls handle fan based on compressor/burner status
  - Example: Modern split AC systems with built-in fan control
  - **Thermostat only controls fan in "cycle" and "on" modes**

**THE BUG THAT WAS FIXED IN THIS PROJECT**:
- ❌ **WRONG**: Fan would turn ON during heating/cooling even when `fanRelayNeeded = false`
- ✅ **CORRECT**: When `fanRelayNeeded = false`, thermostat stays OFF the fan relay during heating/cooling

### Fan Modes Explained

#### 1. **Fan Mode = "on"**
- Fan runs **CONTINUOUSLY** until user manually turns it off
- NOT tied to heating/cooling status
- `fanRelayNeeded` value is IGNORED in this mode

#### 2. **Fan Mode = "auto"**
- Fan runs **ONLY WHEN HVAC is actively heating or cooling**
- **`fanRelayNeeded` controls whether thermostat or HVAC controls the fan**
  - `true`: Thermostat controls fan relay with heating/cooling
  - `false`: HVAC controls fan, thermostat stays off the relay

#### 3. **Fan Mode = "cycle"**
- Fan runs on a **schedule** (e.g., 15 minutes per hour) 
- Cycles independently regardless of heating/cooling status
- NOT affected by `fanRelayNeeded` - always thermostat-controlled

### Standard 24V Thermostat Wiring

**R (Red)**: 24V power from HVAC unit
**W/W1 (White)**: Close to activate heating  
**Y/Y1 (Yellow)**: Close to activate cooling
**G (Green)**: Close to run fan
**C (Common)**: Return path for relays

**How It Works**: When thermostat needs heat, it closes switch between R and W. HVAC furnace receives signal and turns on.

### Bang-Bang Control (What This Device Uses)

On-off switching with hysteresis to prevent rapid cycling:
- Setpoint = 72°F, Swing = 1°F
- Heat ON when: temp < 71°F
- Heat OFF when: temp > 72°F  
- Result: Temperature oscillates between 71-73°F (normal HVAC behavior)

### Multi-Stage Operation

**Stage 1** (Primary): Main heating/cooling capacity
**Stage 2** (Auxiliary): Extra capacity for extreme temperature differences

Stage 2 only activates if:
1. Stage 1 has run for minimum time (default 5 min)
2. AND temperature is still far from setpoint (default 2°F difference)
3. AND stage 2 is enabled in settings

### Hydronic System Support

This project monitors boiler water temperature to prevent heating if water is too cold:
- `hydronicTempLow = 110°F`: Boiler too cold, heating DISABLED (safety lockout)
- `hydronicTempHigh = 140°F`: Boiler hot enough, heating ENABLED (hysteresis)
- Prevents: Rapid cycling, inadequate heating, boiler damage

### Common HVAC System Types This Device Supports

1. **Gas Furnace + Central AC**: Thermostat controls W for heat and Y for cooling
2. **Electric Furnace**: Uses W1/W2 for heating element stages  
3. **Heat Pump**: Requires reversing valve control (not in current project)
4. **Hydronic (Boiler)**: Thermostat monitors water temperature via DS18B20 sensor

### Code Implementation - How Thermostat Follows HVAC Standards

**In `controlRelays()` function**:
1. Check mode (heat/cool/auto/off)
2. Read current temperature
3. Compare to setpoint - swing to determine if heating/cooling needed
4. Call `activateHeating()` or `activateCooling()` or `turnOffAllRelays()`
5. Call `handleFanControl()` to manage fan based on mode and `fanRelayNeeded`

**In `activateHeating()`**:
```cpp
// Close heating relay (W terminal equivalent)
digitalWrite(heatRelay1Pin, HIGH);

// Handle fan based on fanRelayNeeded setting
if (fanRelayNeeded) {
    digitalWrite(fanRelayPin, HIGH);  // Thermostat controls fan
} else {
    digitalWrite(fanRelayPin, LOW);   // HVAC controls fan, stay off
}
```

**In `handleFanControl()` for auto mode**:
```cpp
// Only control fan if thermostat is responsible
if (fanRelayNeeded) {
    newFanState = (heatingOn || coolingOn);  // Fan ON during heat/cool
} else {
    newFanState = false;  // Don't control - HVAC handles it
}
```

### Why This Matters - Real World Examples

**Example 1: Modern Split AC with Built-In Fan Control**
- System: Fujitsu split AC, separate thermostat input for cooling command
- HVAC Behavior: When given Y signal, AC automatically starts compressor AND fan
- Thermostat Setting: `fanRelayNeeded = false`
- Result: Thermostat only sends Y signal, AC handles everything else

**Example 2: Old Forced-Air Furnace**  
- System: 1990s gas furnace with separate fan
- HVAC Behavior: Needs separate W signal for burner AND G signal for fan
- Thermostat Setting: `fanRelayNeeded = true` (in auto mode)
- Result: Thermostat sends W for heat AND G for fan together

**The Bug Scenario**:
- User has Example 1 system (modern AC)
- Sets `fanRelayNeeded = false` (correct)
- Buggy code: Fan relay STILL goes HIGH during heating (wrong!)
- Result: Thermostat fan relay interferes with HVAC's fan control, causing:
  - Fan runs when shouldn't
  - Possible relay contention
  - Confusion about what's controlling what

**After Fix**:
- Same system with `fanRelayNeeded = false`
- Fixed code: Fan relay stays LOW during heating (correct!)
- Thermostat doesn't touch fan, HVAC has full control
- System works as intended

### Debugging Guide

**"Fan comes on unexpectedly"**:
1. Check thermostat mode and fan mode settings
2. If in "auto" mode, check `fanRelayNeeded` setting
3. If false, verify no heating/cooling is active
4. Serial debug: Look for "Fan activated with heat/cool" messages

**"System doesn't heat/cool"**:
1. Check mode is set to "heat", "cool", or "auto"
2. Check temperature is outside setpoint ± swing range
3. Serial debug: Look for relay activation messages
4. Check relay connections to HVAC equipment

**"Temperature won't stabilize"**:
1. Adjust `tempSwing` hysteresis value (try 1.5-2.0°F)
2. Check sensor isn't in draft or near heat source
3. Verify building insulation adequate

